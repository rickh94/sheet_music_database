import collections
from pathlib import Path
from typing import Dict, List, Optional


def write_javascript_head(js_path: Path, hostname: str):
    """Write the top of the javascript file"""
    js_path.parent.mkdir(parents=True, exist_ok=True)
    lines = [
        "// This file is automatically generated",
        "import Axios from 'axios'",
        "",
        "/* ",
        " * asynchronous fluent api for urls from django project using Axios",
        " * Usage: ",
        " * const django = new DjangoURL()",
        " * const res = await django.path.to.endpoint.method(args)",
        " * [do something with response]",
        " */",
        "export default class DjangoURL {",
        "",
        "  constructor(token = '') {",
        f"    this.baseurl = 'https://{hostname}'",
        "    this.path = '/'",
        "    this.token = token",
        "  }",
        "",
    ]
    with js_path.open("w") as js_file:
        js_file.write("\n".join(lines))


def make_html_method(name: str, payload: bool = False) -> str:
    """Generate an html method function"""
    payload_arg = "payload, " if payload else ""
    return "\n".join(
        [
            f"\n  async {name}({payload_arg}initialConfig = " "{}) {",
            "    const { config, url } = this.setupRequest(initialConfig)",
            f"    return Axios.{name}(url, {payload_arg}config)",
            "  }",
        ]
    )


def write_html_methods(js_path: Path):
    """Write the html method functions for the """
    functions = [
        "\n".join(
            [
                "\n  setAuthorization(config) {",
                "    if (this.token) {",
                "      config.headers = config.headers || {}",
                "      config.headers.Authorization = `Token ${this.token}`",
                "    }",
                "    return config",
                "  }",
            ]
        ),
        "\n".join(
            [
                "\n  setupRequest(config) {",
                "    const url = this.url",
                "    this.path = '/'",
                "    config = setAuthorization(config)",
                "    return { config, url }",
                "  }",
            ]
        ),
        make_html_method("get"),
        make_html_method("delete"),
        make_html_method("head"),
        make_html_method("options"),
        make_html_method("post", payload=True),
        make_html_method("put", payload=True),
        make_html_method("patch", payload=True),
    ]
    javascript_lines = "\n".join(functions)
    with js_path.open("a") as js_file:
        js_file.write(javascript_lines)


def write_javascript_foot(js_path: Path, urls: List[str]):
    """Write the end of the javascript file"""
    url_comments = [f" *   {url}" for url in urls]
    lines = [
        "",
        "}",
        "/*",
        " * This was generated from the list of urls: ",
        *url_comments,
        " */",
    ]
    with js_path.open("a") as js_file:
        js_file.write("\n".join(lines))


Method = collections.namedtuple(
    "Method", ["name", "javascript", "with_args"], defaults=(False,)
)


class MethodList:
    def __init__(self):
        self.__methods = []

    def __contains__(self, name: str) -> bool:
        for method in self.__methods:
            if method.name == name:
                return True
        return False

    def __iter__(self):
        """Iterate through methods"""
        yield from self.__methods

    def __getitem__(self, item: str) -> Optional[Method]:
        for method in self.__methods:
            if method.name == item:
                return method
        return None

    def index(self, name: str) -> Optional[int]:
        for i, item in enumerate(self.__methods):
            if item.name == name:
                return i
        return None

    def replace(self, item: Method):
        idx = self.index(item.name)
        self.__methods[idx] = item

    def append(self, item: Method):
        self.__methods.append(item)

    def __str__(self) -> str:
        method_names = []
        for method in self.__methods:
            method_names.append(method.name)
        return str(method_names)


def get_unique_endpoints(urls: List[str]) -> Dict:
    endpoints: dict = {}
    for url in urls:
        url_parts = url.strip("/").split("/")
        end = url_parts.pop()
        arg = None
        if "<" in end:
            arg = end.replace("<", "").replace(">", "")
            end = url_parts.pop()
        if end in endpoints:
            if not endpoints[end]:
                endpoints[end] = arg
        else:
            endpoints[end] = arg

    return endpoints


class MethodFactory:
    def __init__(self, urls: List[str]):
        self.methods = MethodList()
        self.urls = [url.lstrip("/") for url in urls]
        self.endpoints = get_unique_endpoints(self.urls)

    def add_methods_from_endpoints(self):
        """Create the methods for each unique endpoint"""
        for name, arg in self.endpoints.items():
            self.create_method(name, arg)

    def add_parent_methods(self):
        """Create methods for parents of the endpoints that don't already exist"""
        for url in self.urls:
            self._create_parents(url)

    def _create_parents(self, url: str):
        """Create parents of a url if they don't exist"""
        for part in url.split("/"):
            if part not in self.methods and "<" not in part:
                self.create_method(part)

    def create_method(self, item: str, arg: str = ""):
        """Wrapper for creating a method with or without args"""
        if not item:
            return
        if arg:
            self.methods.append(MethodFactory._create_method_with_arg(item, arg))
        else:
            self.methods.append(MethodFactory._create_method_no_arg(item))

    @staticmethod
    def _create_method_no_arg(item: str) -> Method:
        """Create a method for a url with no args"""
        javascript_lines = [
            "",
            f"  get {item.translate(str.maketrans('.-', '__'))}() " + "{",
            f"    this.path += '{item}/'",
            "    return this",
            "  }",
            "",
        ]
        return Method(item, "\n".join(javascript_lines), False)

    @staticmethod
    def _create_method_with_arg(item: str, arg: str) -> Method:
        """Create a method with args"""
        javascript_lines = [
            "",
            f"  {item.translate(str.maketrans('.-', '__'))}({arg} = '') " + "{",
            f"    this.path += '{item}/'",
            f"    if ({arg}) " + "{",
            f"      this.path += {arg} + '/'",
            "    }",
            "    return this",
            "  }",
            "",
        ]
        return Method(item, "\n".join(javascript_lines), True)

    def add_methods_to_file(self, js_path: Path):
        """Add all methods to a file"""
        self.add_methods_from_endpoints()
        self.add_parent_methods()
        for method in self.methods:
            MethodFactory.add_method_to_file(method, js_path)

    @staticmethod
    def add_method_to_file(method: Method, js_path: Path):
        """Add a method to the javascipt file"""
        with js_path.open("a") as js_file:
            js_file.write(method.javascript)


def make_js_api(js_path: Path, urls: List[str], hostname: str):
    """Generate and write file for javascript fluent api"""
    factory = MethodFactory(urls)
    write_javascript_head(js_path, hostname)
    factory.add_methods_to_file(js_path)
    write_html_methods(js_path)
    write_javascript_foot(js_path, urls)
